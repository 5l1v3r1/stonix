#!/usr/bin/python3
###############################################################################
#                                                                             #
# Copyright 2019. Triad National Security, LLC. All rights reserved.          #
# This program was produced under U.S. Government contract 89233218CNA000001  #
# for Los Alamos National Laboratory (LANL), which is operated by Triad       #
# National Security, LLC for the U.S. Department of Energy/National Nuclear   #
# Security Administration.                                                    #
#                                                                             #
# All rights in the program are reserved by Triad National Security, LLC, and #
# the U.S. Department of Energy/National Nuclear Security Administration. The #
# Government is granted for itself and others acting on its behalf a          #
# nonexclusive, paid-up, irrevocable worldwide license in this material to    #
# reproduce, prepare derivative works, distribute copies to the public,       #
# perform publicly and display publicly, and to permit others to do so.       #
#                                                                             #
###############################################################################




# =========================================================================== #
#               Filename          $RCSfile: stonix/stonix_resources.py,v $
#               Description       Security Configuration Script
#               OS                Linux, Mac OS X, Solaris, BSD
#               Author            Dave Kennel
#               Last updated by   $Author: $
#               Notes             Based on CIS Benchmarks, NSA RHEL
#                                 Guidelines, NIST and DISA STIG/Checklist
#               Release           $Revision: 1.0 $
#               Modified Date     $Date: 2010/8/23 14:00:00 $
# =========================================================================== #

############################################################################
#
# stonix - The Security Tool For Unix
#
# This program is designed to harden and configure multiple Unix-like operating
# systems.
#
# This script is installed by the LANL-stonix package if installed from the
# native package format.
# This script will configure the machine to the LANL "standard" as
# defined by the LANL *NIX Configuration Guideline.
#
# It is intended to complete the hardening of Unix-like systems,
# based on the CIS Linux Benchmarks, NSA, or NIST guidance.  The program
# will be evaluated / updated as newer versions of the guidance documents are
# released.
#
# The operation of this program may be tuned by modifying the
# /usr/local/etc/stonix_resources.conf file.
# See the comments in that file for instructions.
#
# Programmer notes:
# All functions and classes shall have pydoc documentation.
# Do not trust input from any source.
# Whenever applicable unit tests using pyunit will be created.
# In all other cases code must be self testing.
# Code should be written to PEP 8 and be checked with pylint.
# Code autogenerated by QT Designer is excepted from the PEP 8 and pylint
# requirements.
# Only use from <module> import <item> when including base classes
# all other imports and usages should stay in independent name spaces.
#

############################################################################
#
# Changelog
#
# 2010-08-23
# - Revision 1.0

"""%prog [options]

Apply security hardening settings according to LANL guidelines.

The following options control the running of the script:
 -f  --fix  Apply system hardening.
 -r  --report  Print a configuration compliance report.
 -u  --update  Check and update the known SUID, GUID, World
         Writable, unowned and/or AIDE databases.
 -G  --gui  Use the GUI interface.
 -c  --gui  Use the Console interface.
 -X  --rollback  Will rollback file changes to pre-STONIX state.
 -h  --help  or no arguments will display this help message and exit.
 -v  --verbose print verbose information about what stor is doing.
 -R  --rule run a single stonix rule. Requires -f, -X or -r.

WARNING! If run with the -f flag THIS PROGRAM WILL MODIFY
SYSTEM SETTINGS!

*********
The system should be rebooted when the script completes for all
changes to take effect.
*********

stonix is a system hardening program produced by the NIE
Development Services team. It is designed to apply hardening settings
to Unix and Unix-like operating systems in accordance with published
security guidelines.

When run with the -f flag the script will apply configuration changes
designed to reduce the attack surface of the system. In all possible
cases the original files will be backed up at
/usr/local/share/stonix/backups and marked with a .ovf for Original
Vendor File. All system changes will also be logged to
/var/log/stonix-info. If you are unfamiliar with the
hardening process please review the hardening guidance from CIS, DISA and NSA.

Created on Aug 23, 2010

@author: David Kennel
@change: 2017/03/07 - David Kennel - Added support for FISMA categorization.
@change: 2017/06/19 - David Kennel - Added safeties to rule loading for redundant
        rule names and numbers.
@change: 2017/07/12 - Breen Malmberg - added method getruleauditonly();
        added to do notes; changed author name formats to be consistent;
        fixed some typo's in the class doc string; updated group name (CSD -> NIE)
@TODO There are some methods that require fixing / completing / re-working (search FIXME)
@TODO All methods need a once-over done on their doc strings
@TODO improve logging/debugging on all methods
@TODO look at adding try/except to all methods missing them
@change: 2019/04/08 - Breen Malmberg - removed unused import 'imp'; fixed unreachable logging calls
"""

# Std Library imports
import sys
import os
import re
import traceback
import time
import subprocess
from pkgutil import extend_path

# Local imports
__path__ = extend_path(os.path.dirname(os.path.abspath(__file__)), 'stonix_resources')
#from . import stonix_resources

from stonix_resources.observable import Observable
from stonix_resources.configuration import Configuration
from stonix_resources.environment import Environment
from stonix_resources.StateChgLogger import StateChgLogger
from stonix_resources.logdispatcher import LogPriority, LogDispatcher
from stonix_resources.program_arguments import ProgramArguments
from stonix_resources.CheckApplicable import CheckApplicable
from stonix_resources.CommandHelper import CommandHelper

from stonix_resources.cli import Cli


class Controller(Observable):
    '''This is the main worker object for stonix. It handles the
    stand up and tear down of the rest of the program.


    '''

    def __init__(self):
        """

        """

        Observable.__init__(self)
        self.environ = Environment()
        self.mode = "gui"
        self.fix = False
        self.report = False
        self.undo = False
        self.runrule = None
        self.pcf = False
        self.pcs = False
        self.list = False

        if not self.safetycheck():
            self.logger.log(LogPriority.CRITICAL,
                            ['SafetyCheck',
                             'ERROR: Installation safety checks failed!'])
            self.logger.log(LogPriority.WARNING,
                            ['SafetyCheck',
                             'STONIX files may only be writable by the ' +
                             'root user!'])
            self.logger.log(LogPriority.WARNING,
                            ['SafetyCheck',
                             'Validate and correct permissions on all ' +
                             'STONIX files and try again.'])
            self.logger.log(LogPriority.WARNING,
                            ['SafetyCheck',
                             'STONIX will now exit.'])
            sys.exit(1)

        # this part added so stonix will create files with the intended root umask (022)
        # instead of using the default user umask (which is currently being set to 077)
        # running stonix with a umask of 077 would break several bits of functionality
        # (namely installbanners, in some cases)
        if self.environ.geteuid() == 0:
            os.umask(0o22)

        self.lockfile = '/var/run/stonix.pid'
        if(self.environ.get_test_mode()):
            self.setuptesting()
        if not self.mode == 'test':
            self.prog_args = ProgramArguments()
            self.processargs()
        self.config = Configuration(self.environ)
        try:
            fismacategory = self.config.getconfvalue('main', 'fismacat')
            self.environ.setsystemfismacat(fismacategory)
        except(KeyError):
            pass
        self.numrulesrunning = 0
        self.numrulescomplete = 0
        self.currulename = ''
        self.currulenum = 0
        self.logger = LogDispatcher(self.environ)
        self.logger.log(LogPriority.DEBUG, 'Logging Started')

        # set session variables needed by stonix which may not normally get
        # set when running under a root context
        self.ch = CommandHelper(self.logger)
        session_vars_dict = {"DBUS_SESION_BUS_ADDRESS": "export $(dbus-launch)"}
        try:
            for sv in session_vars_dict:
                self.set_session_var(sv, session_vars_dict[sv])
        except:
            self.logger.log(LogPriority.WARNING, "Unable to set " + sv + " session variable")
            pass

        self.tryacquirelock()

        if self.mode == 'gui':
            applicable2PyQt5 = {'type': 'white',
                               'os': {'Mac OS X': ['10.10', '+']}}
            applicable2PyQt4 = {'type': 'black',
                               'family': ['darwin']}
            self.chkapp = CheckApplicable(self.environ, self.logger)

            if self.chkapp.isApplicable(applicable2PyQt5):
                #####
                # Appropriate to OS that supports PyQt5
                try:
                    from PyQt5 import QtCore, QtWidgets, QtGui
                    from stonix_resources.gui_pyqt5 import GUI
                except ImportError:
                    pass

                # This resets the UI to the command line if GUI was selected on the
                # command line and PyQt4 isn't present.
                if 'PyQt5' not in sys.modules and self.mode == 'gui':
                    self.mode = 'cli'
                    self.logger.log(LogPriority.ERROR,
                                    'GUI Selected but PyQt5 not available. ' +
                                    'Please install PyQt5 and dependencies for ' +
                                    'GUI functionality.')
                elif 'PyQt5' in sys.modules:
                    app = QtWidgets.QApplication(sys.argv)
                    splashart = os.path.join(self.environ.get_icon_path(),
                                             'StonixSplash.png')
                    splashimage = QtGui.QPixmap(splashart)
                    splash = QtWidgets.QSplashScreen(splashimage,
                                                 QtCore.Qt.WindowStaysOnTopHint)
                    splash.setMask(splashimage.mask())
                    splash.show()
                    app.processEvents()

            if self.chkapp.isApplicable(applicable2PyQt4):
                #####
                # Appropriate to OS that supports PyQt4
                try:
                    from PyQt4 import QtCore, QtGui
                    from stonix_resources.gui import GUI
                except(ImportError):
                    pass

                # This resets the UI to the command line if GUI was selected on the
                # command line and PyQt4 isn't present.
                if 'PyQt4' not in sys.modules and self.mode == 'gui':
                    self.mode = 'cli'
                    self.logger.log(LogPriority.ERROR,
                                    'GUI Selected but PyQt4 not available. ' +
                                    'Please install PyQt4 and dependencies for ' +
                                    'GUI functionality.')
                elif 'PyQt4' in sys.modules:
                    app = QtGui.QApplication(sys.argv)
                    splashart = os.path.join(self.environ.get_icon_path(),
                                             'StonixSplash.png')
                    splashimage = QtGui.QPixmap(splashart)
                    splash = QtGui.QSplashScreen(splashimage,
                                                 QtCore.Qt.WindowStaysOnTopHint)
                    splash.setMask(splashimage.mask())
                    splash.show()
                    app.processEvents()

        self.statechglogger = StateChgLogger(self.logger, self.environ)
        # NB We don't have a main event loop at this point so we call
        # the app.processEvents() again to make the splash screen show
        if self.mode == 'gui':
            app.processEvents()
        self.logger.log(LogPriority.DEBUG,
                        'State Logger Started')
        if not(self.mode == 'test'):
            # This resets the UI to the command line if GUI was selected on the
            # command line and PyQt4 isn't present.
            if 'PyQt4' not in sys.modules and 'PyQt5' not in sys.modules and self.mode == 'gui':
                self.mode = 'cli'
                self.logger.log(LogPriority.ERROR,
                                'GUI Selected but PyQt4 not available. ' +
                                'Please install PyQt4 and dependencies for ' +
                                'GUI functionality.')
        self.statechglogger = StateChgLogger(self.logger, self.environ)
        self.logger.log(LogPriority.DEBUG,
                        'State Logger Started')
        self.logger.log(LogPriority.DEBUG,
                        'Running in ' + self.mode)
        starttime = time.time()
        allrules = self.getrules(self.config, self.environ)
        etime = time.time() - starttime
        self.logger.log(LogPriority.DEBUG,
                        'Rules Processed in ' + str(etime))
        self.installedrules = self.findapplicable(allrules)

        # if no applicable rules are found, exit STONIX with message
        if len(self.installedrules) == 0:
            sys.exit("********************\n\nSTONIX: No applicable rules for this system\n\n********************")

        etime = time.time() - starttime
        self.logger.log(LogPriority.DEBUG,
                        'Rules Applicable in ' + str(etime))
        self.numexecutingrules = len(self.installedrules)
        self.environ.setnumrules(self.numexecutingrules)
        self.logger.logRuleCount()
        self.logger.log(LogPriority.DEBUG,
                        str(self.numexecutingrules) + ' rules loaded')
        self.logger.log(LogPriority.DEBUG,
                        ['CurrentEUID', str(self.environ.geteuid())])
        self.logger.log(LogPriority.DEBUG,
                        ['OSFamily', self.environ.getosfamily()])
        self.logger.log(LogPriority.DEBUG,
                        ['OSType', self.environ.getostype()])
        self.logger.log(LogPriority.DEBUG,
                        ['OSVersion', self.environ.getosver()])
        self.list = self.prog_args.getList()

        if self.list:
            self.__listrules()
        elif self.mode == 'cli':
            self.__clirun()
        elif self.mode == 'gui':
            myui = GUI(self, self.environ, self.logger)
            splash.finish(myui)
            sys.exit(app.exec_())
        elif self.mode == 'test':
            pass

    def set_session_var(self, session_var, set_command):
        '''

        :param session_var: session variable to set
        :param set_command: the command to run to set the given session variable

        '''

        session_var_value = ""

        try:
            session_var_value = os.environ[session_var]
        except KeyError:
            pass

        try:
            if not session_var_value:
                self.ch.executeCommand(set_command)
        except:
            raise

    def getrules(self, config, environ):
        '''Private method to process the stonix rules file to populate the rules.

        :param config: 
        :param environ: 
        :returns: List of instantiated rule objects

        '''
        rulewalklist = []
        instruleclasses = []
        validrulefiles = []
        rulenumbers = []
        rulenames = []
        initlist = ['__init__.py', '__init__.pyc', '__init__.pyo']

        stonixPath = self.environ.get_resources_path()
        self.logger.log(LogPriority.DEBUG,
                        ['STONIX Path:', str(stonixPath)])
        rulesPath = self.environ.get_rules_path()
        self.logger.log(LogPriority.DEBUG,
                        ['Rules Path:', str(rulesPath)])

        sys.path.append(stonixPath)
        sys.path.append(rulesPath)

        for path in sys.path:
            self.logger.log(LogPriority.DEBUG,
                            ['Sys Path Element:', str(path)])

        rulefiles = os.listdir(str(rulesPath))


        #####
        # Check if stonix has been 'frozen' with pyinstaller, py2app, etc and
        # process rules accordingly
        if hasattr(sys, 'frozen'):
            #####
            # Search through the already imported libraries for stonix rules
            for item in list(sys.modules.keys()):
                if re.match("stonix_resources\.rules\.[A-Z]\w+$", item):
                    self.logger.log(LogPriority.DEBUG,
                                    'Key Match: ' + str(item))
                    rulewalklist.append(item)
            self.logger.log(LogPriority.DEBUG,
                            ['Rule Walk list from keys: ', str(rulewalklist)])
        else:
            for rfile in rulefiles:
                if rfile in initlist:
                    continue
                else:
                    validrulefiles.append(rfile)
            self.logger.log(LogPriority.DEBUG,
                            ['validrulefiles: ', str(rulewalklist)])
            # This is a list comprehension to build a list of module names to
            # import based on the names of valid rule files from stonix/rules
            # destination list = [ *transform* *source* *filter* ]
            modulenames = [mod.replace('.py', '') for mod in validrulefiles
                            if re.search("\.py$", mod)]
            self.logger.log(LogPriority.DEBUG,
                            ['Module names:', str(modulenames)])

            # The output of this section is a list of valid, fully qualified,
            # rule class names.
            for module in modulenames:
                module = module.split("/")[-1]

                classname = 'stonix_resources.rules.' + module + '.' + module
                rulewalklist.append(classname)

        self.logger.log(LogPriority.DEBUG,
                        ['Walk list:', str(rulewalklist)])

        for rule in rulewalklist:
            if hasattr(sys, 'frozen'):
                starttime = time.time()
                #####
                # Make sure rules start with a letter...
                self.logger.log(LogPriority.DEBUG,
                                'Using Frozen path for ' + str(rule))
                #####
                # Get just the rule name
                ruleClass = rule.split('.')[2]
                self.logger.log(LogPriority.DEBUG,
                                'Class name after split: ' + str(ruleClass))
                #####
                # Acquire the rule class module
                mod = getattr(sys.modules[rule], ruleClass)
                self.logger.log(LogPriority.DEBUG,
                                'Mod name: ' + str(mod))
            else:
                # This is odd and requires detailed comments. This block imports the
                # modules then recurses down, instantiates the main rule class and
                # appends the class to a list.
                starttime = time.time()
                parts = rule.split(".")
                # the module is the class less the last element
                module = ".".join(parts[:-1])
                # Using the __import__ built in function to import the module
                # since our names are only known at runtime.
                self.logger.log(LogPriority.DEBUG,
                                'Attempting to load: ' + str(module))
                try:
                    mod = __import__(module)
                except Exception:
                    trace = traceback.format_exc()
                    self.logger.log(LogPriority.ERROR,
                                    "Error importing rule: " + trace)
                    continue
                # Recurse down the class name until we get a reference to the 
                # class itself. Then we instantiate using the reference.
                for component in parts[1:]:
                    try:
                        mod = getattr(mod, component)
                    except Exception:
                        trace = traceback.format_exc()
                        self.logger.log(LogPriority.ERROR,
                                        "Error finding rule class reference: "
                                        + str(trace))
                        continue
            try:
                clinst = mod(config, environ,
                             self.logger,
                             self.statechglogger)
                rulenum = clinst.getrulenum()
                self.logger.log(LogPriority.DEBUG,
                                'Checking Rule Number: ' + str(rulenum))
                rulename = clinst.getrulename()
                self.logger.log(LogPriority.DEBUG,
                                'Checking Rule Name: ' + str(rulename))
                if rulenum in rulenumbers:
                    self.logger.log(LogPriority.DEBUG, 'Rule Numbers List: ' + str(rulenumbers))
                    raise ValueError('ERROR: Rule Number ' + str(rulenum) + ' already instantiated! Not loading rule: ' + rulename)
                elif rulename in rulenames:
                    self.logger.log(LogPriority.DEBUG, 'Rule Numbers List: ' + str(rulenames))
                    raise ValueError('ERROR: Rule ' + rulename + ' already instantiated! Not loading rule: ' + str(rulenum))
                else:
                    rulenumbers.append(rulenum)
                    rulenames.append(rulename)
                    instruleclasses.append(clinst)
                etime = time.time() - starttime
                self.logger.log(LogPriority.DEBUG,
                                'load time: ' + str(etime))
            except (KeyboardInterrupt, SystemExit):
                # User initiated exit
                raise
            except Exception:
                trace = traceback.format_exc()
                self.logger.log(LogPriority.ERROR,
                                "Error instantiating rule: " + str(trace))
                continue

        return instruleclasses

    def findapplicable(self, rules):
        '''This method checks each rule to see if it is applicable on the current
        platform on which stonix is running. A list of applicable rule objects
        is returned.

        :param rules: List of instantiated rule objects
        :returns: List of instantiated rule objects
        @author: David Kennel

        '''
        applicablerules = []
        for rule in rules:
            try:
                if rule.isapplicable():
                    self.logger.log(LogPriority.DEBUG,
                                    'Rule is applicable by platform ' +
                                    ' EUID: ' + str(self.environ.geteuid()) +
                                    ' Root required: ' +
                                    str(rule.getisrootrequired()))
                    if self.environ.geteuid() != 0 and rule.getisrootrequired():
                        self.logger.log(LogPriority.DEBUG,
                                    'Skipping ' + rule.getrulename() +
                                    ' root required.')
                    else:
                        self.logger.log(LogPriority.DEBUG,
                                    'Adding ' + rule.getrulename() +
                                    ' to run list.')
                        applicablerules.append(rule)
            except Exception:
                trace = traceback.format_exc()
                self.logger.log(LogPriority.ERROR,
                                "Error determining rule applicability: "
                                + trace)
        return applicablerules

    def getallrulesdata(self):
        '''This method returns a dictionary of lists containing the data for all
        installed rules. Returned properties include; rule name, rule number,
        and the rule help text. The dictionary is keyed by rule number.


        :returns: Dictionary of lists
        @author: David Kennel

        '''
        rulesdata = {}
        for rule in self.installedrules:
            rulenum = rule.getrulenum()
            rulename = rule.getrulename()
            ruletxt = rule.gethelptext()
            ruledetails = []
            ruledetails.append(rulename)
            ruledetails.append(ruletxt)
            rulesdata[rulenum] = ruledetails
        return rulesdata

    def getrulenumbyname(self, name):
        '''This method takes a name associated with a rule as an argument and
        translates it into a number associated with a rule class. Acceptable
        rule names are the section headers from the stonix_resources.conf.
        These section headers are generated from the rulename property that
        each rule has.

        :param string: name of the rule to fetch a number for.
        :param name: 
        :returns: int : number for the rule matching the passed name 0 if no
        match is found.
        @author: David Kennel

        '''
        rulenum = 0
        for rule in self.installedrules:
            rulename = rule.getrulename()
            if rulename == name:
                rulenum = rule.getrulenum()
        return rulenum

    def getrulenamebynum(self, rulenum):
        '''This method takes a number associated with a rule as an argument and
        translates it into a name associated with a rule class. Acceptable
        rule number are integers and are found in rule implementations.

        :param int: number of the rule to fetch a name for.
        :param rulenum: 
        :returns: string : name for the rule matching the passed number. None if
        no match is found.
        @author: David Kennel

        '''
        rulename = None
        for rule in self.installedrules:
            ruleid = rule.getrulenum()
            if rulenum == ruleid:
                rulename = rule.getrulename()
        return rulename

    def hardensystem(self):
        '''Call all rules in fix(harden) mode


        :returns: void :
        @author David Kennel

        '''
        self.numrulesrunning = self.numexecutingrules
        self.numrulescomplete = 0
        for rule in self.installedrules:
            self.currulenum = rule.getrulenum()
            self.currulename = rule.getrulename()
            try:
                self.logger.log(LogPriority.DEBUG, "****************** RULE START: " + str(self.currulename) + " ******************")
                starttime = time.time()
                self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                rule.report()
                self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                if not rule.getrulesuccess():
                    self.logger.log(LogPriority.ERROR,
                                    [rule.getrulename(),
                                     rule.getdetailedresults()])
                elif not rule.iscompliant():
                    self.logger.log(LogPriority.DEBUG, "=================== START FIX ===================")
                    rule.fix()
                    self.logger.log(LogPriority.DEBUG, "==================== END FIX ====================")
                    if rule.getrulesuccess():
                        self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                        rule.report()
                        self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                        if not rule.getrulesuccess():
                            self.logger.log(LogPriority.ERROR,
                                            [rule.getrulename(),
                                             rule.getdetailedresults()])
                        elif not rule.iscompliant():
                            self.logger.log(LogPriority.WARNING,
                                            [rule.getrulename(),
                                            rule.getdetailedresults()])
                        else:
                            self.logger.log(LogPriority.INFO,
                                            [rule.getrulename(),
                                            rule.getdetailedresults()])
                else:
                    self.logger.log(LogPriority.INFO,
                                    [rule.getrulename(),
                                    rule.getdetailedresults()])
                etime = time.time() - starttime
                self.logger.log(LogPriority.DEBUG,
                                [rule.getrulename(),
                                'Elapsed Time: ' + str(etime)])
                self.logger.log(LogPriority.DEBUG, "****************** RULE END: " + str(self.currulename) + " ******************")
            except (KeyboardInterrupt, SystemExit):
            # User initiated exit
                raise
            except Exception:
                trace = traceback.format_exc()
                self.logger.log(LogPriority.ERROR, [rule.getrulename(),
                                "Controller caught rule death: "
                                + trace])
            self.numrulescomplete = self.numrulescomplete + 1
            self.set_dirty()
            self.notify_check()

    def auditsystem(self):
        '''Call all rules in audit(report) mode


        :returns: void :
        @author David Kennel

        '''
        self.numrulesrunning = self.numexecutingrules
        self.numrulescomplete = 0
        for rule in self.installedrules:
            self.currulenum = rule.getrulenum()
            self.currulename = rule.getrulename()
            try:
                self.logger.log(LogPriority.DEBUG, "****************** RULE START: " + str(self.currulename) + " ******************")
                starttime = time.time()
                self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                rule.report()
                self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                etime = time.time() - starttime
                self.logger.log(LogPriority.DEBUG,
                                [rule.getrulename(),
                                'Elapsed Time: ' + str(etime)])
                self.logger.log(LogPriority.DEBUG, "****************** RULE END: " + str(self.currulename) + " ******************")
            except (KeyboardInterrupt, SystemExit):
                # User initiated exit
                raise
            except Exception:
                trace = traceback.format_exc()
                self.logger.log(LogPriority.ERROR, [rule.getrulename(),
                                "Controller caught rule death: "
                                + trace])
            self.numrulescomplete = self.numrulescomplete + 1
            if not rule.getrulesuccess():
                self.logger.log(LogPriority.ERROR,
                                [rule.getrulename(),
                                rule.getdetailedresults()])
            if not rule.iscompliant():
                self.logger.log(LogPriority.WARNING,
                                [rule.getrulename(),
                                rule.getdetailedresults()])
            else:
                self.logger.log(LogPriority.INFO,
                                [rule.getrulename(),
                                rule.getdetailedresults()])
            self.set_dirty()
            self.notify_check()

    def runruleharden(self, ruleid):
        '''Run a single rule in fix(harden) mode

        :param int: ruleid :
        :param ruleid: 
        :returns: void :
        @author David Kennel

        '''
        self.numrulesrunning = 1
        self.numrulescomplete = 0
        rulename = self.getrulenamebynum(ruleid)
        self.logger.log(LogPriority.DEBUG, "****************** RULE START: " + str(rulename) + " ******************")
        self.logger.log(LogPriority.DEBUG, ['RunRuleHarden',
                         'Attempting to run ' + str(ruleid)])

        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                if rule.getisrootrequired() and self.environ.geteuid() != 0:
                    self.numrulescomplete = self.numrulescomplete + 1
                    message = "Could not run rule: insufficient privilege level"
                    self.logger.log(LogPriority.ERROR,
                                    [rule.getrulename(), message])
                else:
                    starttime = time.time()
                    try:
                        self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                        rule.report()
                        self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                    except (KeyboardInterrupt, SystemExit):
                        # User initiated exit
                        raise
                    except Exception:
                        trace = traceback.format_exc()
                        self.logger.log(LogPriority.ERROR, [rule.getrulename(),
                                        "Controller caught rule death: "
                                        + trace])
                    if not rule.getrulesuccess():
                        self.logger.log(LogPriority.ERROR,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                        self.logger.log(LogPriority.INFO,
                                        [rule.getrulename(),
                                         'Rule failed: Rule config in unknown state. Skipping rule'])
                        self.numrulescomplete = self.numrulescomplete + 1
                    elif not rule.iscompliant():
                        try:
                            self.logger.log(LogPriority.DEBUG, "=================== START FIX ===================")
                            rule.fix()
                            self.logger.log(LogPriority.DEBUG, "==================== END FIX ====================")
                        except (KeyboardInterrupt, SystemExit):
                            # User initiated exit
                            raise
                        except Exception:
                            trace = traceback.format_exc()
                            self.logger.log(LogPriority.ERROR,
                                            [rule.getrulename(),
                                            "Controller caught rule death: "
                                            + trace])
                        if not rule.getrulesuccess():
                            self.logger.log(LogPriority.ERROR,
                                            [rule.getrulename(),
                                             rule.getdetailedresults()])
                        try:
                            self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                            rule.report()
                            self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                        except (KeyboardInterrupt, SystemExit):
                            # User initiated exit
                            raise
                        except Exception:
                            trace = traceback.format_exc()
                            self.logger.log(LogPriority.ERROR,
                                            [rule.getrulename(),
                                             "Controller caught rule death: "
                                            + trace])
                        if not rule.iscompliant():
                            self.logger.log(LogPriority.WARNING,
                                            [rule.getrulename(),
                                            rule.getdetailedresults()])
                        else:
                            self.logger.log(LogPriority.INFO,
                                            [rule.getrulename(),
                                            rule.getdetailedresults()])
                    self.numrulescomplete = self.numrulescomplete + 1
                    etime = time.time() - starttime
                    self.logger.log(LogPriority.DEBUG,
                                    [rule.getrulename(),
                                     'Elapsed Time: ' + str(etime)])
                    self.set_dirty()
                    self.notify_check()
        if self.numrulescomplete == 0:
            message = "Could not find rule! Searched for ruleid = " \
            + str(ruleid)
            self.logger.log(LogPriority.ERROR,
                            message)
        self.logger.log(LogPriority.DEBUG, "****************** RULE END: " + str(rulename) + " ******************")

    def runruleaudit(self, ruleid):
        '''Run a single rule in audit(report) mode

        :param int: ruleid :
        :param ruleid: 
        :returns: void :
        @author David Kennel

        '''
        rulename = self.getrulenamebynum(ruleid)
        self.logger.log(LogPriority.DEBUG, "****************** RULE START: " + str(rulename) + " ******************")
        message = "Controller:runruleaudit: Entering rule with id " + \
        str(ruleid)
        self.logger.log(LogPriority.DEBUG, message)
        self.numrulesrunning = 1
        self.numrulescomplete = 0
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                message = "Controller:runruleaudit: Matched rule id"
                self.logger.log(LogPriority.DEBUG, message)
                if rule.getisrootrequired() and self.environ.geteuid() != 0:
                    self.numrulescomplete = self.numrulescomplete + 1
                    message = "Could not run rule: insufficient privilege level"
                    self.logger.log(LogPriority.ERROR,
                                    [rule.getrulename(), message])
                else:
                    starttime = time.time()
                    try:
                        self.logger.log(LogPriority.DEBUG, "=================== START REPORT ===================")
                        rule.report()
                        self.logger.log(LogPriority.DEBUG, "==================== END REPORT ====================")
                    except (KeyboardInterrupt, SystemExit):
                        # User initiated exit
                        raise
                    except Exception:
                        trace = traceback.format_exc()
                        self.logger.log(LogPriority.ERROR,
                                        [rule.getrulename(),
                                        "Controller caught rule death: "
                                        + trace])
                    self.numrulescomplete = self.numrulescomplete + 1
                    if not rule.getrulesuccess():
                        self.logger.log(LogPriority.ERROR,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                    if not rule.iscompliant():
                        self.logger.log(LogPriority.WARNING,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                    else:
                        self.logger.log(LogPriority.INFO,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                    etime = time.time() - starttime
                    self.logger.log(LogPriority.DEBUG,
                                    [rule.getrulename(),
                                     'Elapsed Time: ' + str(etime)])
                    self.set_dirty()
                    self.notify_check()
        self.logger.log(LogPriority.DEBUG, "****************** RULE END: " + str(rulename) + " ******************")

    def undochangessystem(self):
        '''Undo all changes to the system.


        :returns: void :
        @author David Kennel

        '''
        self.numrulesrunning = self.numexecutingrules
        self.numrulescomplete = 0
        for rule in self.installedrules:
            self.currulenum = rule.getrulenum()
            self.currulename = rule.getrulename()
            try:
                rule.undo()
            except (KeyboardInterrupt, SystemExit):
                # User initiated exit
                raise
            except Exception:
                trace = traceback.format_exc()
                self.logger.log(LogPriority.ERROR,
                                [rule.getrulename(),
                                "Controller caught rule death: "
                                + trace])
            self.numrulescomplete = self.numrulescomplete + 1
            if not rule.getrulesuccess():
                self.logger.log(LogPriority.ERROR,
                                [rule.getrulename(),
                                rule.getdetailedresults()])
            else:
                self.logger.log(LogPriority.INFO,
                                [rule.getrulename(),
                                 rule.getdetailedresults()])
            self.set_dirty()
            self.notify_check()

    def undorule(self, ruleid):
        '''Undo the changes from a single rule. Expects the integer rule number
        as the ruleid

        :param int: ruleid :
        :param ruleid: 
        :returns: void :
        @author David Kennel

        '''
        self.numrulesrunning = 1
        self.numrulescomplete = 0
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                if rule.getisrootrequired() and self.environ.geteuid() != 0:
                    self.numrulescomplete = self.numrulescomplete + 1
                    message = "Could not run rule: insufficient privilege level"
                    self.logger.log(LogPriority.ERROR,
                                    [rule.getrulename(), message])
                else:
                    try:
                        rule.undo()
                    except (KeyboardInterrupt, SystemExit):
                        # User initiated exit
                        raise
                    except Exception:
                        trace = traceback.format_exc()
                        self.logger.log(LogPriority.ERROR,
                                        [rule.getrulename(),
                                        "Controller caught rule death: "
                                        + trace])
                    self.numrulescomplete = self.numrulescomplete + 1
                    if not rule.getrulesuccess():
                        self.logger.log(LogPriority.ERROR,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                    else:
                        self.logger.log(LogPriority.INFO,
                                        [rule.getrulename(),
                                        rule.getdetailedresults()])
                    self.set_dirty()
                    self.notify_check()

    def getrulehelp(self, ruleid):
        '''Return rule help information.

        :param int: ruleid : int (identifier) of rule to get help text for.
        :param ruleid: 
        :returns: string :
        @author David Kennel

        '''
        helptxt = []
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                helptxt = rule.gethelptext()
        return helptxt

    def updatedbs(self):
        '''Update all databases held by database rules in stonix_resources.


        :returns: void :
        @author David Kennel

        '''
        numdbrules = 0
        self.numrulescomplete = 0
        for rule in self.installedrules:
            if rule.isdatabaserule():
                numdbrules = numdbrules + 1
        self.numrulesrunning = numdbrules
        for rule in self.installedrules:
            if rule.isdatabaserule():
                self.currulenum = rule.getrulenum()
                self.currulename = rule.getrulename()
                try:
                    self.logger.log(LogPriority.DEBUG, "=================== START FIX ===================")
                    rule.fix()
                    self.logger.log(LogPriority.DEBUG, "==================== END FIX ====================")
                except (KeyboardInterrupt, SystemExit):
                    # User initiated exit
                    raise
                except Exception:
                    trace = traceback.format_exc()
                    self.logger.log(LogPriority.ERROR,
                                    [rule.getrulename(),
                                    "Controller caught rule death: "
                                    + trace])
                self.numrulescomplete = self.numrulescomplete + 1
                self.set_dirty()
                self.notify_check()

    def getconfigoptions(self):
        '''This method retrieves the configitems for all rules and returns a dict
        of lists where the keys are rule names and the lists contain the rule
        text and a list of configitem objects for that rule.


        :returns: dict :
        @author David Kennel

        '''
        configdict = {}
        for rule in self.installedrules:
            rulename = rule.getrulename()
            ruledata = []
            ruledata.append(rule.gethelptext())
            for configitem in rule.getconfigitems():
                ruledata.append(configitem)
            configdict[rulename] = ruledata

        return configdict

    def getruleconfigoptions(self, ruleid):
        '''This method returns the configurationitem object instances associated
        with a rule. We expect to be passed the integer rule number to id the
        rule.

        :param int: ruleid : Integer rule number
        :param ruleid: 
        :returns: list : list of configurationitem objects
        @author David Kennel

        '''
        cilist = []
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                cilist = rule.getconfigitems()
        return cilist

    def regenerateconfig(self, simpleconf):
        '''This method will write the stonix configuration file with the current
        configuration data. If simpleconf is True then we only write changed
        rules and rules that are marked as being in the simple config.
        
        The configuration file object actually does most of the work here.

        :param bool: simpleconf : Whether or not we are generating a simple
        configuration file or not.
        :param simpleconf: 
        :returns: void
        @author David Kennel

        '''
        currdata = self.getconfigoptions()
        self.config.writeconfig(simpleconf, currdata)

    def validateconfig(self):
        '''FIXME - unimplemented method, is this still required/desirable at this
        level?


        :returns: bool :
        @author

        '''
        pass

    def getcurrentrule(self):
        '''This method returns the rule name for the currently executing rule.
        This method only returns valid data when called while the whole rule
        stack is running.


        :returns: string : rulename
        @author David Kennel

        '''
        return self.currulename

    def getrulecompstatus(self, ruleid):
        '''This method returns the compliance status for the named rule. This info
        is only valid after the rule has had the report or fix methods called.

        :param int: ruleid
        :param ruleid: 
        :returns: bool
        @author: David Kennel

        '''
        compliant = False
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                compliant = rule.iscompliant()
        return compliant

    def getruledetailedresults(self, ruleid):
        '''This method returns the detailed results from the rule with a given
        rule id. Returned data will be a string.

        :param int: ruleid
        :param ruleid: 
        :returns: string
        @author: David Kennel

        '''
        detailedresults = []
        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                detailedresults = rule.getdetailedresults()
        return detailedresults

    def getcompletionpercentage(self):
        '''This method returns the percentage of items on the to-do list
        completed. This only returns valid data when called while the whole
        rule stack is running.


        :returns: int : range 0 - 100
        @author David Kennel

        '''
        total = float(self.numrulesrunning)
        curr = float(self.numrulescomplete)
        if self.environ.getdebugmode():
            print("Controller:getcompletionpercentage: Total: " + str(total))
            print("Controller:getcompletionpercentage: Current: " + str(curr))
        if curr == 0:
            percent = 0
        else:
            percent = int((curr / total) * 100)
        if self.environ.getdebugmode():
            print("Controller:getcompletionpercentage: Percent: " + str(percent))
        return percent

    def set_rule_detailedresults(self, ruleid, mode, result, msg):
        '''update the specified rule's (ruleid) detailedresults with the msg from
        the caller; (used to bridge the observable gap between other classes and
        the running rule)

        :param ruleid: int; the rule number identifier
        :param mode: string; fix|report|undo
        :param result: bool; (see rule.py formatDetailedResults())
        :param msg: string; message to update detailedresults with
        @author: Breen Malmberg

        '''

        for rule in self.installedrules:
            if ruleid == rule.getrulenum():
                rule.formatDetailedResults(mode, result, msg)

    def getruleauditonly(self, ruleid):
        '''This method returns the audit only status boolean
        from the rule with a given <ruleid>.

        :param ruleid: int; the rule number identifier
        :returns: auditonly
        :rtype: bool
@author: Breen Malmberg

        '''

        auditonly = False

        try:

            for rule in self.installedrules:
                if ruleid == rule.getrulenum():
                    auditonly = rule.getauditonly()

        except Exception as err:
            self.logger.log(LogPriority.DEBUG, str(err))
            return False
        return auditonly

    def displaylastrun(self):
        '''Returns the contents of the log file by way of the logger object.


        :returns: string :
        @author: ???

        '''
        return self.logger.displaylastrun()

    def updatestatus(self, callingobject):
        '''WARNING! FIX ME! This was intended to be a part of the comms between
        the controller and the view. I'm not sure this method still makes
        sense.

        :param object_: callingobject :
        :param callingobject: 
        :returns: void

        '''
        pass

    def tryacquirelock(self):
        '''Try to set a lock file at /var/run/stonix_resources.pid. If the lock
        file already exists check to see if a stonix process with that PID is
        already running. If so exit with error else re-create lock file with
        our PID.


        :returns: void
        @author: David Kennel

        '''
        lockmessage = """
!WARNING! Another copy of STONIX appears to be running!
Running more than one copy of STONIX at a time may result in
unintended behavior! If STONIX is not running remove the file
/var/run/stonix.pid and re-launch STONIX.
ABORTING EXECUTION!"""
        if not self.environ.geteuid() == 0:
            # only grab a lock file for privileged use.
            return
        if os.path.exists(self.lockfile):
            rw_lockfile = open(self.lockfile, 'r+')
            lockpid = rw_lockfile.readline()
            lockpid = lockpid.strip()
            self.logger.log(LogPriority.DEBUG,
                            ['TryAcquireLock',
                             'Found lock for PID: ' + lockpid])
            try:
                if int(lockpid) == os.getpid():
                    # PID is the same, reuse PID file
                    return
            except (TypeError, ValueError):
                self.logger.log(LogPriority.DEBUG,
                                ['TryAcquireLock',
                                 'Could not coerce PID to INT: ' + lockpid])
            command = None
            if self.environ.getosfamily() == 'freebsd':
                command = '/bin/ps -aux'
            elif self.environ.getosfamily() == 'solaris':
                command = '/usr/bin/ps -ef'
            else:
                command = '/bin/ps -ef'
            self.logger.log(LogPriority.DEBUG,
                            ['TryAcquireLock',
                             'PS command is: ' + str(command)])
            if not type(command) is None:
                pscom = subprocess.Popen(command, stdout=subprocess.PIPE,
                                         stderr=subprocess.PIPE,
                                         shell=True, close_fds=True)
                psout = pscom.stdout.readlines()
                for line in psout:
                    line = str(line)
                    if re.search('stonix', line):
                        splits = line.split()
                        pspid = splits[1]
                        self.logger.log(LogPriority.DEBUG,
                                        ['TryAcquireLock',
                                         'Checking PIDs: ' + lockpid + ' ' + \
                                         pspid])
                        if pspid == lockpid:
                            self.logger.log(LogPriority.DEBUG,
                                            ['TryAcquireLock',
                                             'Matched PIDs: ' + lockpid + ' ' \
                                             + pspid])
                            self.logger.log(LogPriority.CRITICAL,
                                            ['TryAcquireLock', lockmessage])
                            rw_lockfile.close()
                            sys.exit(2)
            self.logger.log(LogPriority.DEBUG,
                            ['TryAcquireLock',
                             'Truncating existing Lockfile'])
            rw_lockfile.truncate(0)
            rw_lockfile.write(str(os.getpid()))
            rw_lockfile.close()
        else:
            self.logger.log(LogPriority.DEBUG,
                            ['TryAcquireLock',
                             'Creating new Lockfile'])
            rw_lockfile = open(self.lockfile, 'w')
            rw_lockfile.write(str(os.getpid()))
            rw_lockfile.close()

    def safetycheck(self):
        '''Check that the installation of STONIX is safe from a security
        perspective. All files must only be writable by root.
        
        @author: David Kennel


        :returns: bool True if install passes checks

        '''
        safe = True
        return safe

    def releaselock(self):
        '''Cleans up the stonix lock file in the event of normal program
        exit.


        :returns: void
        @author: David Kennel

        '''

        if os.path.exists(self.lockfile):
            try:
                os.remove(self.lockfile)
            except:
                # the lock release can cause errors when run w/o privilege
                # and a lock file has been left behind by a privileged run.
                pass

    def processargs(self):
        '''This method calls the prog_args instance to process the command line
        args and then jumps to the appropriate execution mode.
        
        @author: Roy Nielsen, David Kennel


        :returns: void

        '''
        self.environ.setverbosemode(self.prog_args.get_verbose())
        self.environ.setdebugmode(self.prog_args.get_debug())
        self.fix = self.prog_args.get_fix()
        self.report = self.prog_args.get_report()
        self.undo = self.prog_args.get_rollback()
        self.environ.setinstallmode(self.prog_args.get_install())
        self.pcf = self.prog_args.getPrintConfigFull()
        self.pcs = self.prog_args.getPrintConfigSimple()

        if self.prog_args.get_update():
            # update(debug)
            pass

        if self.prog_args.get_rollback():
            # rollback()
            pass

        if not re.match("^\s*$", self.prog_args.get_module()):
            runrule = self.prog_args.get_module()
            breakIndex = runrule.find(",")
            if breakIndex > 0:
                rulelist = []
                done = False
                while not done:
                    rulelist.append(runrule[0:breakIndex])
                    if len(runrule) > breakIndex:
                        runrule = runrule[breakIndex+1:]
                        breakIndex = runrule.find(",")
                        if breakIndex > 0:
                            continue
                        else:
                            rulelist.append(runrule)
                            done = True
                    else:
                        done = True
                self.runrule = rulelist
            else:
                self.runrule = runrule

        if self.prog_args.get_gui():
            self.mode = 'gui'

            # uiinstance = view.View(uimode)

        if self.prog_args.get_cli():
            self.mode = 'cli'

    def setuptesting(self):
        '''this method is called when the environment object determins that the
        controller is in test mode - e.g. running from a unittest.
        
        @author: Ekkehard J. Koch


        :returns: void

        '''
        self.environ.setverbosemode(True)
        self.environ.setdebugmode(True)
        self.fix = False
        self.report = False
        self.undo = False
        self.environ.setinstallmode(False)
        self.runrule = ""
        self.mode = 'test'

    def __listrules(self):
        """
        Private method that prints the list of currently installed and
        applicable rules. This is a part of the STONIX CLI user interface and
        is needed for users to be able to list rules available to run in module
        mode. The program will exit after this method is complete.

        @author: David Kennel
        @return: void
        """
        rulelist = []
        for rule in self.installedrules:
            rulenum = rule.getrulenum()
            rulename = rule.getrulename()
            rulestring = rulename + ' (' + str(rulenum) + ')'
            rulelist.append(rulestring)
        rulelist.sort(key=str.lower)
        print("STONIX rules for this platform:")
        for rule in rulelist:
            print(rule)
        try:
            self.logger.closereports()
        except:
            pass
        self.releaselock()

    def __clirun(self):
        """
        This private method performs a cli run based on the passed flags.

        @author: David Kennel
        @return: void
        """
        self.logger.log(LogPriority.DEBUG,
                        ['Controller.__clirun',
                         ' __clirun called'])
        myui = Cli(self.environ)
        # self.logger.register_listener(myui)
        self.register_listener(myui)
        if not self.runrule:
            self.logger.log(LogPriority.DEBUG,
                            'Entering full system run')
            if self.fix:
                self.logger.log(LogPriority.DEBUG,
                                'Mode is Fix')
                self.hardensystem()
                self.logger.closereports()
            if self.report:
                self.logger.log(LogPriority.DEBUG,
                                'Mode is Report')
                self.auditsystem()
                self.logger.postreport()
            if self.undo:
                self.logger.log(LogPriority.DEBUG,
                                'Mode is Undo')
                self.undochangessystem()
                self.logger.closereports()
            if self.pcf:
                self.logger.log(LogPriority.DEBUG,
                                'Generating Full config file')
                self.regenerateconfig(False)
                self.logger.closereports()
            if self.pcs:
                self.logger.log(LogPriority.DEBUG,
                                'Generating Simple config file')
                self.regenerateconfig(True)
                self.logger.closereports()
            if not self.fix and not self.report and not self.undo and \
            not self.pcf and not self.pcs:
                self.logger.log(LogPriority.INFO,
                                'No action specified. Please check command syntax')
                self.logger.closereports()

        elif isinstance(self.runrule, list):
            self.logger.log(LogPriority.DEBUG,
                            'Running rules: ' + ", ".join(self.runrule))
            for rule in self.runrule:
                self.logger.log(LogPriority.DEBUG,
                               'Entering single rule run for ' + rule)
                ruleid = self.getrulenumbyname(rule)
                self.logger.log(LogPriority.DEBUG,
                               'Rule ID number ' + str(ruleid))
                if self.fix:
                    self.logger.log(LogPriority.DEBUG,
                                    'Mode is Fix')
                    self.runruleharden(ruleid)
                    self.logger.closereports()
                if self.report:
                    self.logger.log(LogPriority.DEBUG,
                                    'Mode is Report')
                    self.runruleaudit(ruleid)
                    self.logger.closereports()
                if self.undo:
                    self.logger.log(LogPriority.DEBUG,
                                    'Mode is Undo')
                    self.undorule(ruleid)
                    self.logger.closereports()
                if not self.fix and not self.report and not self.undo:
                    self.logger.log(LogPriority.INFO,
                                    'No action specified. Please pass the -r, -f, or -u flag')
                self.logger.closereports()
        else:
            self.logger.log(LogPriority.DEBUG,
                           'Entering single rule run ' + self.runrule)
            ruleid = self.getrulenumbyname(self.runrule)
            self.logger.log(LogPriority.DEBUG,
                           'Rule ID number ' + str(ruleid))
            if self.fix:
                self.logger.log(LogPriority.DEBUG,
                                'Mode is Fix')
                self.runruleharden(ruleid)
                self.logger.closereports()
            if self.report:
                self.logger.log(LogPriority.DEBUG,
                                'Mode is Report')
                self.runruleaudit(ruleid)
                self.logger.closereports()
            if self.undo:
                self.logger.log(LogPriority.DEBUG,
                                'Mode is Undo')
                self.undorule(ruleid)
                self.logger.closereports()
            if not self.fix and not self.report and not self.undo:
                self.logger.log(LogPriority.INFO,
                                'No action specified. Please pass the -r, -f, or -u flag')
                self.logger.closereports()
        self.releaselock()

if __name__ == '__main__':
    STONIXAPP = Controller()
